![colorScript](https://user-images.githubusercontent.com/78071591/160069349-cf500f89-7777-45e0-962b-8593c55e9467.png)

> ## 동기

---

- 이번에 진행한 프로젝트는 Color-Script 라는 visual studio extension 입니다.  
  개발을 하다보면 많은 변수를 사용하게 되는데 변수명을 통해 타입을 유추할 수도 있지만 좀 더 직관적으로 데이터 타입을 알 수 있다면 코드를 작성하는 사람과 읽는 사람 모두에게 편리함을 줄 수 있겠다는 생각으로부터 시작되었으며 저에게는 새로운 방향의 개발로서 도전하는 의미도 가진 프로젝트 입니다.

<br /><br />

> ## 기술

---

### Java Script

- 주요 기술로는 프로젝트의 목표 중 하나로 문자열을 이용해 기능을 구현해내는 것으로 라이브러리의 추가 사용없이  
  바닐라 자바스크립트로 작성하였습니다

<br /><br />

> ## 스케줄

---

### 1 주차

- 아이디어 기획
  Visual Studio Extension Api 검토

* Task Card

### 2, 3 주차

- 칸반을 바탕으로 기능을 구현 및 작업해 Pull Request의 흐름과 칸반의 흐름을 맞춰서 개발 진행

- semantic token 이용한 커스텀 토큰 맵핑 처리

- String, Number, Boolean, Null, Undefined, Array, Ojbect 의 리터럴한 입력값에 인식, 맵핑 처리

- 재할당 , 호이스팅 처리

- Array.length / Array[index] / Object.property 형식의 문법 인식 , 맵핑 처리

- 블럭스코프 / 함수스코프 기능 일부 구현 (로직 불충분으로 인한 제거)

- Import / Export 인식 , 맵핑 처리

- 다중연산 처리

- 리팩토링 (함수분리)

<br /><br />

> ## 기능

---

- 실행환경 : Vs Code의 활성화된 에디터의 확장자가 .js일 경우에만 동작하도록 하였습니다.

<br /><br />

```
"editor.semanticTokenColorCustomizations": {
    "enabled": true,
    "rules": {
      "type.declaration.boolean": {
        "foreground": "#e74c3c",
        "fontStyle": "bold"
      },
      "type.declaration.string": {
        "foreground": "#0be881",
        "fontStyle": "bold"
      },
      "type.declaration.number": {
        "foreground": "#f1c40f",
        "fontStyle": "bold"
      },
      "type.declaration.null": {
        "foreground": "#D6A2E8",
        "fontStyle": "bold"
      },
      "type.declaration.undefined": {
        "foreground": "#9b59b6",
        "fontStyle": "bold"
      },
      "type.declaration.array": {
        "foreground": "#e67e22",
        "fontStyle": "bold"
      },
      "type.declaration.object": {
        "foreground": "#3742fa",
        "fontStyle": "bold"
      }
    }
  },
```

- setting.json에 위의 코드를 붙여 넣어 사용합니다. 코드의 rules 부분을 보면  
  7가지의 데이터 타입을 확인 할 수 있는데 foreground의 값을 변경해 색상을 조합 할 수 있습니다.

<br /><br />

---

<img src="https://user-images.githubusercontent.com/78071591/158436862-c9fe8073-1856-473f-8956-d834c9a38665.gif" width="600" height="400">

- 코드의 실행단위를 기준으로 " ; " (세미콜론)을 입력해야 정상적으로 동작합니다.
  이렇게 처리한 이유는 ASI가 세미콜론은 대신입력해 주지만  
  이것은 선택사항이며 ASI가 파싱 과정에 에러발생을 방지하기 위해 작동하는 것이기 때문에 " ; " 을 입력하는 것이
  옳다는 판단이 들었기 때문입니다.

- String : "" , '' , `` 모두 인식하도록 처리 했습니다.

- Number : + , - , / , \* , % , ( , ) , . 기호와 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9
  숫자를 이용해 처리했습니다. 더욱 다양한 연산기호도 존재하지만  
  문자열로 다양한 케이스의 연산을 모두 처리하는것은 어려운 부분이 있다고 생각해  
  isNaN 메서드와 가장 일반적인 기호와 숫자를 이용해 체크했습니다.

- Boolean : true , false외 !를 붙이면 Boolean 타입이 되도록 했습니다.

- Null : null을 할당할 경우 타입이 맵핑되도록 했습니다.

- Undefined : undefined를 할당하거나 var, let 으로 선언한 변수에 값을 할당하기 전,  
  var로 선언한 변수를 선언하기전 사용했을때의 경우 할당되도록 하였습니다.

- Array : [ , ] , ; 기호를 이용해 타입을 확인했습니다.

- Object : { , } , ; 기호를 이용해 타입을 확인했습니다.

- Array[index] : string타입의 배열을 array 타입으로 변환 후 [index] 를 확인하고 타입을 맵핑하였습니다.

- Array.length , String.length : .length 앞에 선언된 값의 타입을 체크하여 string, array의 경우를  
  인식하여 number 타입으로 맵핑하였습니다.

- Object.property : Object를 객체화 시킨뒤에 property의 value로 타입을 체크해 맵핑하였습니다.

<br /><br />

<img src="https://user-images.githubusercontent.com/78071591/158436877-180dce01-9788-43bd-9384-cee4b46c1c60.gif" width="600" height="400">

- 호이스팅 : const, let 으로 선언한 변수도 호이스팅이 되지만 선언전 사용할 경우 Temporal Dead Zone을 이유로  
  참조에러가 발생하기 때문에 어떠한 타입도 맵핑하지 않도록 처리했습니다.  
  var로 선언한 변수는 선언전 사용시 undefined를 할당하며 선언이후에는 선언시의 데이터 타입을 따르도록 했습니다.

- 재할당 : key: 변수, value: 변수의 데이터를 담고있는 객체를 요소로 가진 배열로 이루어진  
  parsing 한 객체를 통해 const로 선언된 변수는 재할당되지 못하도록 하였으며  
  let과 var로 선언된 변수에는 재할당시에는 parsing객체에 변수명을 key로 가진 value(배열)에 push 하며 갱신하였습니다.

- Import / Export : Vs Code Api를 이용해 현재 파일의 경로를 얻고, import 구문에서 경로를 가져와  
  편집하고 import하는 파일의 코드를 fs 모듈을 통해 불러와서 export, export default 구문만 필터링 하여  
  작성한 parsing 함수를 통해 객체화시켜 사용하여 처리했습니다.

<br /><br />

> ## 챌린지

---

- 문자열 상태의 객체 Parsing

  문자열 상태의 객체를 파싱하며 처음 떠올린 방법은 JSON.parse 메서드로 파싱을 위해  
  문자열 객체의 Key에 " "를 감싸주는 함수를 만들어 시도했으나 Undefined, Function 타입의 파싱이 누락되는 부분이  
  발생하기 때문에 다른 방식을 채택해야 했습니다.  
  객체의 내부는 매우 다양한 케이스로 작성될 수 있기 때문에 vm2의 사용을 고려해 테스트 진행했습니다.  
  아래의 문자열 객체를 예로 들어 구문을 실행시키면 어떤 결과가 나올까요?

  ```
  eval(`{ a: 100, b: "100" };`);
  vm.run(`{ a: 100, b: "100" };`);

  결과: Uncaught SyntaxError: Unexpected token ':'
  ```

  예상한 결과와 같으신가요? 저는 에러를 보고 당황하였습니다. 그리고 이해하지 못해 원인은 찾은결과
  인자로 넣는 String은 자바스크립트 구문이여야 하며 위의 코드를 인식한 결과는 아래와 같습니다.
  설명을 위해 줄바꿈 처리한 상태로 표시하였습니다.

  ```
  `{ // 객체의 시작이아닌 블럭의 시작으로 인식합니다.
    a: 100, // 블럭의 시작이후 a: 이 부분에서 알 수 없는 구문으로 작성된 코드이므로 에러가 발생합니다.
    b: "100"
  };`
  ```

  해결방법은 의외로 간단했습니다. 그룹연산자로 묶어 블럭의 시작이아닌 객체로 인식하도록 처리할 수 있었습니다.

  ```
  eval("(" + "{ a: 100, b: '100' }" + ");");
  ```

  이후 vm2를 반드시 설치해서 사용해야 할까? 라는 의문이 들었고 Function을 이용해 처리하지 않는 이유에 대해  
  알아보았습니다.

  사용자의 코드는 문자열로 넘어와 node 환경에서 돌아가게 됩니다. 이 과정에서 this는 global이 되며  
  global에는 많은 정보가 담겨있고 이를 악의적으로 사용할 경우 치명적인 문제가 발생할 수 있는 점이  
  가장 큰 이유라고 느꼈습니다.

  그렇지만 서비스같이 다른유저의 코드를 받아 서버에서 실행하는 환경이 아닌  
  확장을 설치한 컴퓨터에서 자신의 VS Code 내부 현재 활성화된 에디터에서만 확장의 로직이 수행되며  
  공유하지 않으므로 사용할 수 있다고 판단했고

  외부변수를 참조하지 않아도 되며 속도도 eval 보다 50배이상 빠른 Function을 사용하기로 결정했습니다.
  이후 값에 변수를 사용하지 않은 객체는 이상없이 파싱되었으나 변수명을 값으로 가진경우 참조할 변수가
  없어 참조에러가 발생하였는데 이 경우에는 문자열로 객체를 파싱하는 로직을 추가적으로 적용하여 해결하였습니다.

<br/><br/>

- Block 스코프 , Function 스코프

  Block 스코프와 Function 스코프를 구현하기위해 먼저 구조를 생각하였습니다.  
  내부 Block 스코프에서는 외부 Block 스코프의 변수를 사용할 수 있지만  
  외부 Block 스코프에서는 내부 Block 스코프에서 var로 선언된 변수만 가져올 수 있도록 해야 했기에  
  Block 스코프의 범위의 코드를 묶어 파싱함수를 재귀로 실행히며 input으로 파싱된객체를 넣어주고  
  output으로 var로 선언한 변수만 파싱된객체에 넣어 사용할 수 있도록 했습니다.

  if, elseif, else , while , for 문을 기본으로 인식할 수 있도록 작업하고
  Function 스코프를 이어서 구현하였습니다.  
  Function 스코프에는 var, let, const 모두 갇히기 때문에 input으로 파싱된 객체를 , output은 없도록 설정했습니다.

  함수의 실행은 매개변수를 통해 동적으로 데이터 타입이 변하고 실행되는 순간 결정되기 때문에  
   타입을 유추하기 어려운 부분이 있다고 생각해 우선 스코프 구현에 집중했습니다.

  함수는 호이스팅 되므로 선언전 실행문을 사용할 수 있는데 이 점에 부딪히며 예상외로 동작하고,  
   대응하지 못하는 케이스들이 다발하는 상황이 발생했고 3 ~ 4일 정도 시간을 소요하며 개선을 시도했지만  
   결국 실패하였습니다.

  해당 개념을 구현하는 일은 저에게 도전이였고 결과는 아쉽지만 자바스크립트 엔진의 동작도 들여다 보게되며  
   Byte Data -> Byte Stream Decoder -> Token생성 -> Pre-parser, Parser -> Node생성 -> AST(추상구문트리) ->  
   Interpreter (type feedback) -> Compiler를 보며 parser와 Node생성 그리고 AST의 구조를 만들어야 한다는 점을  
   느끼며 프로젝트 구조 및 설계에 대한 문제점도 인지할 수 있었습니다.

  이미 시간이 지체된 상황이라 리셋하고 진행할 수 없었기에 걷어내는 결정을 하였고 반드시 훗날에 실패로만 남지 않도록  
   유보라고 결정하고 더욱 성장한 후에 시도하자 라는 마음으로 다음 스케줄을 진행했습니다.

<br/><br/>

- Import / Export  
  VS Code API에서 현재 파일의 코드는 가져올 수 있으나 원하는 파일의 코드를 현재 활성화된 에디터의 문자열로  
  이루어진 코드에서 얻은 정보로 가져오는 방법을 찾지 못하며 난항을 겪었습니다.

  import 구문을 보면 from 뒤에 경로가 있는데 해당 경로로 node의 fs 모듈을 이용해 코드를  
  문자열로 읽어오는 아이디어를 생각해 시도하려고 했으나 웹팩과정에서 fs 모듈을 찾지 못하는 이슈가 있었는데  
  보일러 플레이트만으로 작업을 했기에 느낀 문제점이였고 웹팩 5에서는 node의 기본 제공 모듈을 자동으로  
  폴리필 해주지 않기 때문에 require 옵션을 통해 fs 모듈을 해석할 수 있도록 하며 해결하였습니다.

  import구문에서 from뒤의 경로를 통해 절대경로를 생성하여 해당 파일이 코드를 fs모듈을 통해 불러와  
  export, export default 구문을 파싱하는 로직을 추가하고 import xxx, { yyy, zzz } 형식과 맵핑시켜  
  해당 모듈을 할당받는 변수의 타입을 지정할 수 있었습니다.

  import, export 기능을 흉내내는 정도의 로직을 구성하였지만 추상적인 생각을 코드로 실현시키는 과정에서  
  Step을 잘 나누어 진행하면 순간순간에 집중할 수 있고 작은단위로 발전시켜 기능을 완성시킬 수 있다는 자신감과  
  스스로 어렵고 와닿지 않는 개발을 진행할 때 매우 중요하게 작용하다는 점을 알게 되었습니다.

<br /><br />

> ## 마무리

---

- 프로젝트의 시작하기전 아이디어를 구상하며 코딩을 통한 결과물의 종류가 웹뿐이였던 저에게 코딩을 하는 순간순간 개발자에게 도움을 줄 수 있는 이 프로젝트는 매우 흥미로웠습니다.

  그렇지만 익스텐션을 개발하기위해 VS Code 공식문서를 살펴보며 다양한 api 중 프로젝트에 적합한 api를 찾지 못해 고민도 했었습니다.

  그 동안은 직접 구현한 것도 있었지만 npm을 통한 패키지가 워낙 많았기에 더 적합한 것을 찾는 고민을 했던 경험은 있었지만  
  찾지못해 고민한 경험은 저에게 api를 다르게 바라보는 시각을 얻을 수 있게 했습니다.

  처음 선택한 VS Code의 Text Editor Decoration는 원하는 커스텀 타입을 만들고 조건을 설정해 스타일을 입힐 수 있었지만  
  확장자 문제와 이벤트 실행방식에 대한 복잡성의 증가의 이유로 중간에 Semantic Token을 이용한 방식으로 전환하여 진행했습니다.

  방식의 전환으로 조건을 설정해 스타일을 맵핑하는 점은 같지만 확장자의 선택과 , 이벤트의 실행방식을  
  간결하게 가져갈 수 있는 이점이 있었습니다.

  그리고 가장 중요한 이번 프로젝트의 핵심인 최대한 외부 라이브러리를 사용하지 않고 문자열로 이루어진  
  코드를 기반으로 구현하는 방식을 통해 바닥부터 하나하나 완성해 나가며  
  처음 계획했던 부분보다 훨씬 더 세밀하게 계획해야 했던 부분들도 확인하며 고민을 통한 성장도 했으나  
  시간을 들인만큼 아웃풋이 나오지 않은 부분 또한 존재해 매우 아쉬운 기억도 남았지만  
  모든 과정에서 얻은 가치들은 가장 뿌듯한 경험으로 기억될것 같습니다.

  기간을 짧게 두고 진행한 프로젝트라 모든케이스의 대응하지 못하는 부분도 있고  
  아직 구현해야할 많은 기능들이 남았지만 아이디어 -> 개발 -> 실체화의 프로세스를 통해 얻은  
  개발자 입장에서의 자신감, 도전, 성취감 등을 마음에 잘 새겨 추후에 속한 조직과 사회에도  
  좋은 가치와 영향을 줄 수 있는 개발자로 정진할 수 있도록 하겠습니다.
